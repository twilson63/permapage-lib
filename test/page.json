{
  "code": "fd4d6994-04f8-417e-a7b7-4e49a4cb3fd7",
  "type": "page",
  "creator": "vh-NTHVvlKZqRxc8LyyTNok65yQ55a_PJ1zWLb9G2JI",
  "contentType": "text/html",
  "title": "Permapage format v3",
  "description": "A new format for permapages",
  "topics": [
    ""
  ],
  "protocol": "PermaPages-v0.3",
  "content": "# Permapages document version 3\n\nAbstract\n\nPermapages is a publishing protocol that allows creators to author documents in markdown and publish them in html. Before v3 the protocol persisted three artifacts to the permaweb. A path manifast to attached the contract to, a html file as the output of the page and a json document as the source of the permapage. This process requires the user to sign three documents and the system must manage all three of these documents, this can create unexpected errors, it is not very atomic. So with v3 we publish one document that contains the contract, source and output, this document, stringifies and compresses the source into a meta tag called source. Then when the file is loaded for edit, the file is parsed to grab the source attribute and loads all of the data in the editor. This will result in an atomic permapage, \n\nIn order for this to work, we have a simple library that handles the parsing and compressing for us, this way, we can easily load and save permapages in our ux.\n\n```js\n\nfunction save(page) {  \n\t// stringify deflate page\n  const source = base64.fromByteArray(pako.deflate(JSON.stringify(page)))\n\t// transform and return html\n\tconst file = await unified()\n\t  .use(remarkParse)\n\t\t.use(remarkRehype)\n\t\t.use(rehypeDocument, { title: page.title, meta: [{name: 'source', content: source}]})\n\t\t.use(rehypeStringify)\n\t\t.process(page.source)\n\t\t\n\treturn String(file)\n}\n\nfunction open(html) {\n  const result = await unified()\n\t  .use(rehypeParse)\n\t\t.use(rehypeExtractMeta)\n    .use(rehypeStringify)\n\t\t.process(html)\n  // inflate and parse\n\tconst page = pako.inflate(\n\t\tbase64.toByteArray(result.data.meta.source),\n\t\t{ to: 'string'}\n  )\n  return page\n}\n```\n\n\nThese two functions will enable applications to leverage the permapage format to consume and present permapages in presentation and edit modes. And keep them atomic in nature.\n",
  "html": "<div class=\"flex flex-col md:flex-row space-x-4\">  \n        <div class=\"flex-1 md:min-h-screen\">\n          <div class=\"prose md:prose-lg lg:prose-xl m-8 md:mx-24 \">\n          <h1>Permapages document version 3</h1>\n<p>Abstract</p>\n<p>Permapages is a publishing protocol that allows creators to author documents in markdown and publish them in html. Before v3 the protocol persisted three artifacts to the permaweb. A path manifast to attached the contract to, a html file as the output of the page and a json document as the source of the permapage. This process requires the user to sign three documents and the system must manage all three of these documents, this can create unexpected errors, it is not very atomic. So with v3 we publish one document that contains the contract, source and output, this document, stringifies and compresses the source into a meta tag called source. Then when the file is loaded for edit, the file is parsed to grab the source attribute and loads all of the data in the editor. This will result in an atomic permapage,</p>\n<p>In order for this to work, we have a simple library that handles the parsing and compressing for us, this way, we can easily load and save permapages in our ux.</p>\n<pre><code class=\"language-js\">\nfunction save(page) {  \n\t// stringify deflate page\n  const source = base64.fromByteArray(pako.deflate(JSON.stringify(page)))\n\t// transform and return html\n\tconst file = await unified()\n\t  .use(remarkParse)\n\t\t.use(remarkRehype)\n\t\t.use(rehypeDocument, { title: page.title, meta: [{name: 'source', content: source}]})\n\t\t.use(rehypeStringify)\n\t\t.process(page.source)\n\t\t\n\treturn String(file)\n}\n\nfunction open(html) {\n  const result = await unified()\n\t  .use(rehypeParse)\n\t\t.use(rehypeExtractMeta)\n    .use(rehypeStringify)\n\t\t.process(html)\n  // inflate and parse\n\tconst page = pako.inflate(\n\t\tbase64.toByteArray(result.data.meta.source),\n\t\t{ to: 'string'}\n  )\n  return page\n}\n</code></pre>\n<p>These two functions will enable applications to leverage the permapage format to consume and present permapages in presentation and edit modes. And keep them atomic in nature.</p>\n</div></div>\n        <div class=\"flex-none\">\n          <div class=\"flex flex-col max-w-[300px] justify-end space-y-8\">\n            \n          </div>\n        </div\n      </div>\n      ",
  "profile": false,
  "weavemail": false,
  "ethwallet": "",
  "timestamp": "2023-02-05T14:46:24.299Z",
  "theme": "default",
  "includeFooter": true,
  "allowStamps": false,
  "widgets": [],
  "webpage": "FBp6cirgCldUy67anBCcecKzVctDlCR9kcjlX9T6Wtw"
}